
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `CustomerAddress` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums.ts"
import type * as Prisma from "../internal/prismaNamespace.ts"

/**
 * Model CustomerAddress
 * 
 */
export type CustomerAddressModel = runtime.Types.Result.DefaultSelection<Prisma.$CustomerAddressPayload>






export type CustomerAddressOrderByInput = {
  division?: Prisma.SortOrder
  district?: Prisma.SortOrder
  upazilla?: Prisma.SortOrder
  location?: Prisma.SortOrder
}

export type CustomerAddressCompositeFilter = {
  equals?: Prisma.CustomerAddressObjectEqualityInput
  is?: Prisma.CustomerAddressWhereInput
  isNot?: Prisma.CustomerAddressWhereInput
}

export type CustomerAddressUpdateEnvelopeInput = {
  set?: Prisma.CustomerAddressCreateInput
  update?: Prisma.CustomerAddressUpdateInput
}

export type CustomerAddressWhereInput = {
  AND?: Prisma.CustomerAddressWhereInput | Prisma.CustomerAddressWhereInput[]
  OR?: Prisma.CustomerAddressWhereInput[]
  NOT?: Prisma.CustomerAddressWhereInput | Prisma.CustomerAddressWhereInput[]
  division?: Prisma.StringFilter<"CustomerAddress"> | string
  district?: Prisma.StringFilter<"CustomerAddress"> | string
  upazilla?: Prisma.StringFilter<"CustomerAddress"> | string
  location?: Prisma.StringFilter<"CustomerAddress"> | string
}

export type CustomerAddressUpdateInput = {
  division?: Prisma.StringFieldUpdateOperationsInput | string
  district?: Prisma.StringFieldUpdateOperationsInput | string
  upazilla?: Prisma.StringFieldUpdateOperationsInput | string
  location?: Prisma.StringFieldUpdateOperationsInput | string
}



export type CustomerAddressSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  division?: boolean
  district?: boolean
  upazilla?: boolean
  location?: boolean
}, ExtArgs["result"]["customerAddress"]>



export type CustomerAddressSelectScalar = {
  division?: boolean
  district?: boolean
  upazilla?: boolean
  location?: boolean
}

export type CustomerAddressOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"division" | "district" | "upazilla" | "location", ExtArgs["result"]["customerAddress"]>

export type $CustomerAddressPayload = {
  name: "CustomerAddress"
  objects: {}
  scalars: {
    division: string
    district: string
    upazilla: string
    location: string
  }
  composites: {}
}

export type CustomerAddressGetPayload<S extends boolean | null | undefined | CustomerAddressDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$CustomerAddressPayload, S>





/**
 * Fields of the CustomerAddress model
 */
export interface CustomerAddressFieldRefs {
  readonly division: Prisma.FieldRef<"CustomerAddress", 'String'>
  readonly district: Prisma.FieldRef<"CustomerAddress", 'String'>
  readonly upazilla: Prisma.FieldRef<"CustomerAddress", 'String'>
  readonly location: Prisma.FieldRef<"CustomerAddress", 'String'>
}
    

// Custom InputTypes
/**
 * CustomerAddress without action
 */
export type CustomerAddressDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CustomerAddress
   */
  select?: Prisma.CustomerAddressSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CustomerAddress
   */
  omit?: Prisma.CustomerAddressOmit<ExtArgs> | null
}
